Authorize
=========
authorize is a Ruby on Rails plugin providing a sophisticated Role-Based Access Control (RBAC) system.  It started as a spinoff of Bill Katz's 
Authorization plugin, but has been substantially tested, debugged and enhanced since then.  Current functionality highlights include:

 * Polymorphic association of ActiveRecord models as subjects.
 * Three-level (global, class, instance) authorizations over subjects.
 * Trustee identification via a flexible token system, supporting groups, "public" authorizations and proxies.
 * "Acts" to support a single ActiveRecord model being both a subject and a trustee.
 * Dynamic methods on subjects and trustees support domain-specific syntax: user.is_owner_of(widget)? and widget.is_owned_by?(user)
 * Performance-optimized Domain-Specific Language (DSL) for more sophisticated predicates (available in ActionController at controller and action level).

For more information on the theory of RBAC, see http://en.wikipedia.org/wiki/Role-based_access_control, but note that the term "subject" is used where this plugin uses the term "trustee".

----------------

The authorize plugin extends ActionController with the ability to check permissions and react accordingly.  There are two approaches:
a simple boolean check (permit?) and a more sophisticated predicated block (permit) with exception handling.  In both cases, the method accepts
a permissions description string expressed in a domain-specific language.  The simplest version of this language is just the name of the required 
global/generic role.  For example, using the boolean version:

	permit? "adminstrator"

More complex expressions typically involve requiring a particular role over a particular model instance.  For example:

	permit? "owner of :widget"  

Clean hooks are available for identifying the appropriate authorization tokens for the current request.  No "User" class is assumed, no "current_user"
method is required.

The authorize plugin extends ActiveRecord with two methods: acts_as_subject and acts_as_trustee.  A given model may invoke
either or both, depending on requirements.  The follow narrative shows the methods added to models for management of 
role-based authorization.
 
ActiveRecord-provided associations (see AR documentation for complete list of related methods)
  Trustee (User or Group, for example)
    authorizations
          Returns array of authorizations belonging to trustee
          Deprecated equivalent: roles
    subjected_<subjected_models>   # Note the use of the plural model name
          Returns authorized model objects
          Not yet implemented
  Subject (Widget, for example)
    subjections  # Synonym for authorizations -must be distinct to permit model as both trustee and subject.
          Returns array of authorizations over acts_as_subject objects.
          Deprecated equivalent: accepted_roles
    authorized_<trustee_models>
          Returns array of trustees with an authorization over the acts_as_subject object.
          Not yet implemented
  Authorization
    trustee
          Returns the authorized trustee
    subject
          Returns the object of the authorization
    subjected_<subjected_model>     # Note the use of the singular model name
          Returns subjected model object of named class.  NB: This association is only safe with UUID-keyed models!
          Disabled
    authorized_<authorized_model>      # Note the use of the singular model name
          Returns authorized trustee object of named class.  NB: This association is only safe with UUID-keyed trustees!
          Disabled
Standard plugin methods:
  Trustee
    authorize <Role>, <Subject Instance or Class>
          Creates an authorization for the trustee as <Role> over the subject Instance or Class.  If neither an instance nor a class is specified,
          the trustee is granted a generic/global authorization.
    unauthorize <Role>, <Subject Instance or Class>
          Removes any authorization for the trustee as <Role> over the subject Instance or Class.  Leave off the instance or class to remove a
          generic authorization.
    authorized? <Role>, <Subject Instance or Class>
          Boolean condition for the trustee being authorized as the <Role> over the subject Instance or Class.  Leave off the instance or class to
          check for a generic/global authorization.
  Subject (Authorizable Class or Instance)
    subject <Role>, <Trustee>
          Subjects the model instance or class to the authority of trustee as the named role.
    unsubject <Role>, <Trustee>
          Removes any authorization for the trustee as the named role over the model instance or class
    subjected? <Role>, <Trustee>
          Boolean condition for the the model Instance or Class being subjected to the authority of trustee as the named role.
Identity Mixin methods:
  Trustee
    is_<Role>_for_what
          Returns array of subjects for which trustee as <Role> is authorized
    is_<Role>_<Preposition>?(<Authorizable object>)
          Boolean condition for trustee as <Role> being authorized for the specified subject.
    is_<Role>[_<Preposition> <Authorizable object>]
          Creates authorization for trustee as <Role> either generically or over the specified subject (model or class)
    is_<Role>
          Creates generic authorization to trustee as <Role>
  Subject
    has_<Role>
          Returns array of trustees having specified role over the subject.
    has_<Role>?
          Boolean conditioned upon at least one trustee having <Role> over the subject.
          
----------------

A Note on Authoriztion Tokens

Authorization Tokens are the key to an authorization.  Consequently, they support a security model based on something virtually possessed by the user
rather than simply an attribute of the user.  How a user accumulates authorization tokens is up to you.  Here are some ideas:

	1. Create a "Public" token and persist it with the application configuration.  In a before_filter, accumulate this token (probably the first one).
	2. Create a token for each user and persist it in his user model instance.  When he authenticates, accumulate his token.
	3. Allow a user to affiliate with groups that also have a persisted token.  When membership is ascertained, accumulate the group token.
	4. Create a shared secret token on and display it to the "owner".  Provide a page where any user can prove he shares the secret by entering 
	   the token, which can be a simple Authorization.find_by_token(), and accumulate the token.  Note that allowing users to grab tokens like this
	   can be a security risk if "private" tokens can be guessed.  Resolve the problem by using hashs as tokens.  Shared secret tokens are in fact a
	   hash of the true shared secret (which can be a user selected phrase, a bubblebabble, etc.) while private tokens are a hash of a random
	   discarded value.  Then, in theory, private tokens can only be accessed by guessing the discarded random value or by looking up the actual
	   token on the user model instance.

----------------

A Note on Performance

Performance of the <Subject Class>.authorized named scope is critical to effective use of this plugin.  However, it is difficult to optimize across multiple
database systems for multiple use cases.  Empirically, it seems to be best to use a UNION of the three cases that can yield an authorization: global, class-
based and instance based.  Alternatives using moderately complex nested or expanded OR clauses fail to optimize correctly on MySQL 5.0 and degrade terribly 
with substantial authorization and subject volume.  Not surprisingly, COALESCE also fails to optimize nicely.  A JOIN-based solution was considered, but the
semantics of a JOIN are such that duplicate subject records are returned.  The duplicates could be eliminated with :group and :having options, but at the cost
of transparency of the #authorized named scope.

Indexing of the authorization table is very important.  See the test application's schema for an reasonable set of indices.

Code examples of alternatives:

          # Baseline with nested booleans
          c1 = Authorization.sanitize_sql_hash_for_conditions(:subject_type => nil)
          c2 = Authorization.sanitize_sql_hash_for_conditions(:subject_type => base_class.name)
          c3l = "%s.%s" % [reflection.quoted_table_name, connection.quote_column_name(reflection.primary_key_name)]
          c3r = "%s.%s" % [connection.quote_table_name(table_name), connection.quote_column_name(primary_key)]
          c4 = Authorization.sanitize_sql_hash_for_conditions(:subject_id => nil)
          subject_condition_clause = "#{c1} OR (#{c2} AND (#{c3l} = #{c3r} OR #{c4}))"
          named_scope :a0, lambda {|tokens, roles|
            scope = Authorization.scoped(:conditions => subject_condition_clause).with(tokens).as(roles)
            c = scope.construct_finder_sql({:select => 1, :from => "#{reflection.quoted_table_name} a"}).gsub(/#{reflection.quoted_table_name}\./, 'a.')
            {:conditions => "EXISTS (%s)" % c}
          }

          # Baseline with booleans expanded into three ORs
          c1 = Authorization.sanitize_sql_hash_for_conditions(:subject_type => nil)
          c2 = Authorization.sanitize_sql_hash_for_conditions(:subject_type => base_class.name)
          c3l = "%s.%s" % [reflection.quoted_table_name, connection.quote_column_name(reflection.primary_key_name)]
          c3r = "%s.%s" % [connection.quote_table_name(table_name), connection.quote_column_name(primary_key)]
          c4 = Authorization.sanitize_sql_hash_for_conditions(:subject_id => nil)
          subject_condition_clause = "#{c1} OR (#{c2} AND #{c3l} = #{c3r}) OR (#{c1} AND #{c4})"
          named_scope :a1, lambda {|tokens, roles|
            scope = Authorization.scoped(:conditions => subject_condition_clause).with(tokens).as(roles)
            c = scope.construct_finder_sql({:select => 1, :from => "#{reflection.quoted_table_name} a"}).gsub(/#{reflection.quoted_table_name}\./, 'a.')
            {:conditions => "EXISTS (%s)" % c}
          }

          # COALESCE replacing OR (and a subtle but harmless semantic shift)
          auth_fk = "#{reflection.quoted_table_name}.#{connection.quote_column_name(reflection.primary_key_name)}"
          subject_pk = "#{connection.quote_table_name(table_name)}.#{connection.quote_column_name(primary_key)}"
          auth_fk_type = "#{reflection.quoted_table_name}.#{connection.quote_column_name(Authorization.reflections[:subject].options[:foreign_type])}"
          subject_condition_clause = "%s = COALESCE(#{auth_fk_type}, %s) AND #{subject_pk} = COALESCE(#{auth_fk}, #{subject_pk})" % ([connection.quote(base_class.name)] * 2)
          named_scope :a2, lambda {|tokens, roles|
            scope = Authorization.scoped(:conditions => subject_condition_clause).with(tokens).as(roles)
            c = scope.construct_finder_sql({:select => 1, :from => "#{reflection.quoted_table_name} a"}).gsub(/#{reflection.quoted_table_name}\./, 'a.')
            {:conditions => "EXISTS (%s)" % c}
          }

          # Correlated subquery with COALESCE
          auth_fk = "#{reflection.quoted_table_name}.#{connection.quote_column_name(reflection.primary_key_name)}"
          subject_pk = "#{connection.quote_table_name(table_name)}.#{connection.quote_column_name(primary_key)}"
          auth_fk_type = "#{reflection.quoted_table_name}.#{connection.quote_column_name(Authorization.reflections[:subject].options[:foreign_type])}"
          subject_condition_clause = "%s = COALESCE(#{auth_fk_type}, %s)" % ([connection.quote(base_class.name)] * 2)
          select_clause = "COALESCE(#{auth_fk}, #{subject_pk})"
          named_scope :a3, lambda {|tokens, roles|
            scope = Authorization.scoped(:conditions => subject_condition_clause).with(tokens).as(roles)
            c = scope.construct_finder_sql({:select => select_clause})
            {:conditions => "#{subject_pk} IN (#{c})"}
          }

          # Three-way union - nice performance but UGLY query
          auth_fk = "#{reflection.quoted_table_name}.#{connection.quote_column_name(reflection.primary_key_name)}"
          subject_pk = "#{connection.quote_table_name(table_name)}.#{connection.quote_column_name(primary_key)}"
          named_scope :a4, lambda {|tokens, roles|
            scope = Authorization.with(tokens).as(roles)
            sq0 = scope.construct_finder_sql({:select => true, :conditions => {:subject_id => nil, :subject_type => nil}})
            sq1 = scope.construct_finder_sql({:select => true, :conditions => {:subject_type => base_class.name, :subject_id => nil}})
            sq2 = scope.scoped(:conditions => "#{auth_fk} = #{subject_pk}").construct_finder_sql({:select => true, :conditions => {:subject_type => base_class.name}})
            {:conditions => "EXISTS (#{sq0} UNION #{sq1} UNION #{sq2})"}
          }

          # Join - possible to get nice performance, but semantics collapse
          auth_fk = "#{reflection.quoted_table_name}.#{connection.quote_column_name(reflection.primary_key_name)}"
          subject_pk = "#{connection.quote_table_name(table_name)}.#{connection.quote_column_name(primary_key)}"
          auth_fk_type = "#{reflection.quoted_table_name}.#{connection.quote_column_name(Authorization.reflections[:subject].options[:foreign_type])}"
          subject_condition_clause = "%s = COALESCE(#{auth_fk_type}, %s) AND #{subject_pk} = COALESCE(#{auth_fk}, #{subject_pk})" % ([connection.quote(base_class.name)] * 2)
          named_scope :a9, lambda {|tokens, roles|
            ascope = Authorization.with(tokens).as(roles).current_scoped_methods[:find][:conditions]
            {:joins => "JOIN authorizations ON #{subject_condition_clause}", :conditions => {:authorizations => ascope}}
          }
